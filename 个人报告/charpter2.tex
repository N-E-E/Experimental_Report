\documentclass[supercite]{Experimental_Report}

\usepackage{algorithm, multirow}
\usepackage{algpseudocode}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{framed}
\usepackage{mathtools}
\usepackage{subcaption}
\usepackage{xltxtra} %提供了针对XeTeX的改进并且加入了XeTeX的LOGO, 自动调用xunicode
%宏包(提供Unicode字符宏)
\usepackage{bm}
\usepackage{tikz}
\usepackage{tikzscale}
\usepackage{pgfplots}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{fontspec}

%%%%%%settings%%%%%%%%%
\pgfplotsset{compat=1.16}
\setmonofont{Consolas}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\lstset{ %
	backgroundcolor=\color{white},   % choose the background color
	basicstyle=\footnotesize\ttfamily,        % size of fonts used for the code
	columns=fullflexible,
	breaklines=true,                 % automatic line breaking only atwhitespace
	captionpos=b,                    % sets the caption-position to bottom
	tabsize=4,
	commentstyle=\color{mygreen},    % comment style
	escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
	keywordstyle=\color{blue},       % keyword style
	stringstyle=\color{mymauve}\ttfamily,     % string literal style
	frame=single,
	rulesepcolor=\color{red!20!green!20!blue!20},
	% identifierstyle=\color{red},
	language=c++,
}


\begin{document}
	\section{附录B 基于链式存储结构线性表实现的源程序}
	\noindent
	\begin{center}
		\textbf{/* Linear Table On LinkList Structure */}
	\end{center}
	main.cpp
	\begin{lstlisting}
		#include "def.h"
		#include "LinkList.h"
		#include "Management.h"
		#include "command_op.h"
		
		int main()
		{
			cout << "Initializing..." << endl;
			Manager MainList;
			cout << "An empty list has been constructed." << endl;
			cout << "Use the following command to operate the list." << endl;
			int op, state;
			int flag = 1;
			main_menu();
			cout << "enter your command:" << endl;
			cin >> op;
			while (op) {
				switch (op) {
					case 1:
					state = MainList.NewList();
					if (state) {
						cout << "Complete. now the structure is:" << endl;
						structure_disp(MainList);
					}
					else {
						cout << "Memory error!" << endl;
						flag = 0;
					}
					break;
					case 2:
					int index;
					cout << "enter the num of the list:" << endl;
					cin >> index;
					state = MainList.DelList(index);
					if (state == OK) {
						cout << "delete successfully. Now the structure is:" << 
						endl;
						structure_disp(MainList);
					}
					else if (state == INFEASIBLE) {
						cout << "empty table!" << endl;
					}
					else {
						cout << "index out of range." << endl;
						//flag = 0;
					}
					break;
					case 3:
					/*单独使用一个函数来处理单链表操作*/
					state = single_list_op(MainList);
					if (state == ERROR) cout << "index out of range" << endl;
					cout << "now the structure is:" << endl;
					structure_disp(MainList);
					break;
					case 4:
					structure_disp(MainList);
					break;
					default:
					cout << "wrong command!" << endl;
				}
				if (flag == 0) break;
				main_menu();
				cout << "enter your command:" << endl;
				cin >> op;
			}
			cout << "bye." << endl;
			return 0;
		}
	\end{lstlisting}
	def.h
	\begin{lstlisting}
		#pragma once
		#include <iostream>
		#include <fstream>
		#include <vector>
		#include <algorithm>
		#include "stdio.h"
		#include "stdlib.h"
		using namespace std;
		#define TRUE 1
		#define FALSE 0
		#define OK 1
		#define ERROR 0
		#define INFEASIBLE -1
		#define OVERFLOW -2
		typedef int status;
		typedef int ElemType; //数据元素类型定义
		#define LIST_INIT_SIZE 100
		#define LISTINCREMENT  10
		typedef int ElemType;
		typedef struct LNode {  //单链表（链式结构）结点的定义
			ElemType data;
			struct LNode* next;
		}LNode, * LinkList;
	\end{lstlisting}
	LinkList.h
	\begin{lstlisting}
		#pragma once
		#include "def.h"
		
		class List {
			private:
			int length;
			LinkList head;  //空表头
			LinkList tail;  //指向尾部的指针方便操作
			
			public:
			List* down;  //为线性表管理做准备，采用十字链表存储
			
			List();
			
			//获取头指针
			LinkList GetHead();
			
			//初始化表
			status InitList();
			
			//为表添加数据
			status AddData();
			
			//销毁线性表
			status DestroyList();
			
			//清空线性表
			status ClearList();
			
			//线性表判空
			status ListEmpty();
			
			//返回线性表长度
			int ListLength();
			
			//获取第i个元素，保存在e中
			status GetElem(int i, ElemType& e);
			
			//查找元素e的位置序号
			status LocateElem(ElemType e);
			
			//获取线性表L中元素e的前驱，保存在pre中
			status PriorElem(ElemType e, ElemType& pre);
			
			//获取线性表L元素e的后继，保存在next中
			status NextElem(ElemType e, ElemType& next);
			
			//将元素e插入到线性表L的第i个元素之前
			status ListInsert(int i, ElemType e);
			
			//删除线性表L的第i个元素，并保存在e中
			status ListDelete(int i, ElemType& e);
			
			//遍历单链表
			status ListTraverse();
			
			//以文件形式保存表
			status SaveList(char FileName[]);
			
			//从文件加载表
			status LoadList(char FileName[]);
			
			//反转链表
			status reverse();
			
			//删除倒数第n个节点
			status del_n();
			
			//链表排序
			status SortList();
		};
		
		LinkList _reverse(LinkList l, LinkList r);
	\end{lstlisting}
	LinkList.cpp
	\begin{lstlisting}
		#include "LinkList.h"
		
		List::List() {
			this->head = nullptr;
			this->tail = nullptr;
			this->length = 0;
			this->down = nullptr;
		}
		
		LinkList List::GetHead() {
			return this->head;
		}
		
		status List::AddData() {
			if (!this->head) return INFEASIBLE;
			cout << "enter a series of numbers sperated thit a space and end 
			with 0" << endl;
			int num;
			cin >> num;
			while (num) {
				this->tail->next = (LinkList)malloc(sizeof(struct LNode));
				this->tail = this->tail->next;
				this->tail->next = nullptr;
				this->tail->data = num;
				this->length++;
				cin >> num;
			}
			cout << "Add successfully." << endl;
			return OK;
		}
		
		status List::InitList() {
			if (this->head) return INFEASIBLE;
			this->head = (LinkList)malloc(sizeof(struct LNode));
			this->head->next = nullptr;
			this->tail = head;
			return OK;
		}
		
		status List::DestroyList() {
			if (!this->head) return INFEASIBLE;
			LinkList p;
			LinkList L = this->head;
			while (L) {
				p = L;
				L = L->next;
				free(p);
			}
			this->head = nullptr;
			this->tail = nullptr;
			this->length = 0;
			return OK;
		}
		
		status List::ClearList() {
			if (!this->head) return INFEASIBLE;
			LinkList p;
			LinkList L0 = this->head->next;
			while (L0) {
				p = L0;
				L0 = L0->next;
				free(p);
			}
			this->head->next = nullptr;
			this->length = 0;
			return OK;
		}
		
		status List::ListEmpty() {
			if (!this->head) return INFEASIBLE;
			if (this->length == 0) return TRUE;
			return FALSE;
		}
		
		int List::ListLength() {
			if (!this->head) return INFEASIBLE;
			return this->length;
		}
		
		status List::GetElem(int i, ElemType& e) {
			if (this->head == nullptr) return INFEASIBLE;
			int cnt = 1;
			LinkList L = this->head->next;
			while (L) {
				if (cnt == i) {
					e = L->data;
					return OK;
				}
				L = L->next;
				cnt++;
			}
			return ERROR;
		}
		
		status List::LocateElem(ElemType e) {
			if (this->head == nullptr) return INFEASIBLE;
			int cnt = 1;
			LinkList L = this->head->next;
			while (L) {
				if (L->data == e) return cnt;
				L = L->next;
				cnt++;
			}
			return ERROR;
		}
		
		status List::PriorElem(ElemType e, ElemType& pre) {
			if (this->head == nullptr) return INFEASIBLE;
			LinkList L = this->head;
			if (L->next == nullptr || L->next->data == e) return ERROR;
			L = L->next;
			while (L) {
				if (L->next == nullptr) return ERROR;
				if (L->next->data == e) {
					pre = L->data;
					return OK;
				}
				L = L->next;
			}
		}
		
		status List::NextElem(ElemType e, ElemType& next) {
			if (!this->head) return INFEASIBLE;
			LinkList L = this->head;
			if (!L->next || !L->next->next) return ERROR;
			L = L->next;
			while (L) {
				if (L->data == e) {
					if (L->next) {
						next = L->next->data;
						return OK;
					}
					else return ERROR;
				}
				L = L->next;
			}
			return ERROR;
		}
		
		status List::ListInsert(int i, ElemType e) {
			LinkList L = this->head;
			if (!this->head) return INFEASIBLE;
			int cnt = 1;
			while (L->next) {
				if (cnt == i) {
					if (L->next == nullptr) {
						L->next = new (struct LNode);
						L->next->data = e;
						L->next->next = nullptr;
						this->length++;
						//L = L0;
						return OK;
					}
					LinkList new_node = new (struct LNode);
					new_node->data = e;
					new_node->next = L->next;
					L->next = new_node;
					//L = L0;
					this->length++;
					return OK;
				}
				L = L->next;
				cnt++;
			}
			return ERROR;
		}
		
		status List::ListDelete(int i, ElemType& e) {
			if (!this->head) return INFEASIBLE;
			LinkList L = this->head;
			int cnt = 1;
			while (L->next) {
				if (cnt == i) {
					e = L->next->data;
					LinkList cell = L->next;
					L->next = L->next->next;
					free(cell);
					//L = L0;
					this->length--;
					return OK;
				}
				cnt++;
				L = L->next;
			}
			//L = L0;
			return ERROR;
		}
		
		status List::ListTraverse() {
			if (!this->head) return INFEASIBLE;
			LinkList L = this->head;
			if (L->next == nullptr) return OK;
			L = L->next;
			while (L) {
				printf("%d ", L->data);
				L = L->next;
			}
			return OK;
		}
		
		status List::SaveList(char FileName[]) {
			if (!this->head) return INFEASIBLE;
			FILE* fp = fopen(FileName, "w");
			LinkList L = this->head->next;
			while (L) {
				fprintf(fp, "%d ", L->data);
				L = L->next;
			}
			fclose(fp);
			return OK;
		}
		
		status List::LoadList(char FileName[]) {
			if (this->head) return INFEASIBLE;
			this->head = new (struct LNode);
			LinkList L0 = this->head;
			FILE* fp = fopen(FileName, "r");
			int num;
			while (fscanf(fp, "%d", &num) != EOF) {
				L0->next = new (struct LNode);
				L0 = L0->next;
				L0->data = num;
				this->length++;
			}
			L0->next = nullptr;
			fclose(fp);
			return OK;
		}
		
		status List::reverse() {
			if (!this->head) return INFEASIBLE;
			if (this->length <= 1) return OK;
			LinkList pre = this->head->next, cur = pre->next, next0 = cur->next;
			while (cur) {
				cur->next = pre;
				pre = cur;
				cur = next0;
				if (next0) next0 = next0->next;
			}
			this->head->next->next = nullptr;
			this->head->next = pre;
			return OK;
		}
		
		status List::del_n() {
			cout << "enter the n:" << endl;
			int n, e;
			cin >> n;
			n = this->length - n + 1;
			return this->ListDelete(n, e);
		}
		
		status List::SortList() {
			if (!this->head) return INFEASIBLE;
			if (this->length <= 1) return OK;
			
			vector<int> arr;
			LinkList cur = this->head->next;
			while (cur) {
				arr.push_back(cur->data);
				cur = cur->next;
			}
			cur = this->head->next;
			sort(arr.begin(), arr.end());
			for (int i = 0; i < arr.size(); i++) {
				cur->data = arr[i];
				cur = cur->next;
			}
			return OK;
		}
		
		LinkList _reverse(LinkList l, LinkList r) {
			if (l->next == r) {
				r->next = l;
				return l;
			}
			l = _reverse(l->next, r)->next;
			return l;
		}
	\end{lstlisting}
	management.h
	\begin{lstlisting}
		#pragma once
		#include "def.h"
		#include "LinkList.h"
		
		/*多线性表管理：用十字链表方式存储*/
		class Manager {
			private:
			int length;
			List* start;
			List* end;
			
			public:
			Manager();
			
			//访问私有变量
			List* GetStart();
			List* GetEnd();
			int GetLen();
			
			//在最后添加一个表,并完成初始化以及数据读入
			status NewList();
			
			//不自动读入数据，为文件管理服务
			status NewList(int mode);
			
			//删除最后一张表
			status DelList(int index);
		};
	\end{lstlisting}
	management.cpp
	\begin{lstlisting}
		#include "Management.h"
		
		Manager::Manager() {
			this->length = 0;
			this->start = new List();
			this->end = this->start;
		}
		
		List* Manager::GetStart() {
			return this->start;
		}
		
		List* Manager::GetEnd() {
			return this->end;
		}
		
		int Manager::GetLen() {
			return this->length;
		}
		
		status Manager::NewList() {
			this->end->down = new List();
			if (!this->end->down) return ERROR;
			this->end = this->end->down;
			//this->end->InitList();
			this->end->down = nullptr;
			this->length++;
			
			int state;
			state = this->end->InitList();
			if (state) {
				cout << "initialize successfully" << endl;
			}
			else return ERROR;
			this->end->AddData();
			return OK;
		}
		
		status Manager::NewList(int mode) {
			this->end->down = new List();
			if (!this->end->down) return ERROR;
			this->end = this->end->down;
			//this->end->InitList();
			this->end->down = nullptr;
			this->length++;
			
			int state;
			state = this->end->InitList();
			if (state) {
				cout << "initialize successfully" << endl;
			}
			else return ERROR;
		}
		
		status Manager::DelList(int index) {
			if (this->start == this->end) return INFEASIBLE;
			List* pre = this->start;
			List* L = pre->down;
			int cnt = 1;
			while (L && cnt < index) {
				pre = L;
				L = L->down;
				cnt++;
			}
			if (cnt == index && L) {
				if (pre->down == this->end) {
					this->end = pre;
				}
				pre->down = L->down;
				delete L;
				this->length--;
				return OK;
			}
			else {
				return OVERFLOW;
			}
		}
	\end{lstlisting}
	command\_op.h
	\begin{lstlisting}
		#pragma once
		#include "def.h"
		#include "LinkList.h"
		#include "Management.h"
		
		//菜单输出
		void main_menu();
		void menu_disp();
		
		//展示树形结构
		void structure_disp(Manager M);
		
		//对某一list操作
		status single_list_op(Manager M);
	\end{lstlisting}
	command\_op.cpp
	\begin{lstlisting}
		#include "command_op.h"
		
		void main_menu() {
			printf("          Menu for Linear Table Manager\n");
			printf("-------------------------------------------------\n");
			printf("    	  1. NewList       2. DelList\n");
			printf("          3. goto          4. disp_tree_structure\n");
			printf("          0. quit\n");
			printf("-------------------------------------------------\n");
		}
		
		void menu_disp() {
			printf("             Menu for Single Linear \n");
			printf("-------------------------------------------------\n");
			printf("    	  1. InitList       7. LocateElem\n");
			printf("    	  2. DestroyList    8. PriorElem\n");
			printf("    	  3. ClearList      9. NextElem \n");
			printf("    	  4. ListEmpty      10. ListInsert\n");
			printf("    	  5. ListLength     11. ListDelete\n");
			printf("    	  6. GetElem        12. ListTraverse\n");
			printf("          13. reverseList   14. RemoveNthFromEnd\n");
			printf("          15. SortList      16. AddData\n");
			printf("          17. SaveList      18. LoadList\n");
			printf("    	  0. Exit\n");
			printf("-------------------------------------------------\n");
			
		}
		
		void structure_disp(Manager M) {
			cout << "---------------------------------" << endl;
			if (M.GetStart() == M.GetEnd()) {
				cout << "|--main_list" << endl;
				cout << "   |--empty" << endl;
			}
			else {
				cout << "|--main_list" << endl;
				List* sublist = M.GetStart()->down;
				for (int i = 1; i <= M.GetLen(); i++) {
					if (sublist->GetHead() == nullptr) {
						cout << "   |--null" << endl;
					}
					else if (sublist->ListLength() == 0) {
						cout << "   |--initialized, length 0" << endl;
					}
					else {
						cout << "   |--initialized, length " << 
						sublist->ListLength() << endl;
					}
					sublist = sublist->down;
				}
			}
			cout << "---------------------------------" << endl;
		}
		
		status single_list_op(Manager M) {
			cout << "enter the index of the list:" << endl;
			int pos;
			cin >> pos;
			if (pos > M.GetLen()) return ERROR;
			
			cout << "operation for a sngle list:" << endl;
			menu_disp();
			
			int cnt = 1;
			List* L = M.GetStart()->down;
			while (cnt != pos) {
				L = L->down;
				cnt++;
			}
			
			cout << "input your command:" << endl;
			int op, state;
			int i, e, pre, next;
			char name[100];
			cin >> op;
			while (op) {
				switch (op) {
					case 1:
					state = L->InitList();
					if (state == INFEASIBLE) cout << "The list has existed!" << 
					endl;
					else {
						cout << "initialize successfully! Now the structure 
						is:" << endl;
						structure_disp(M);
					}
					break;
					case 2:
					state = L->DestroyList();
					if (state == INFEASIBLE) cout << "The list doesn't 
					existed!" << endl;
					else {
						cout << "destroy successfully! now the structure is:" 
						<< endl;
						structure_disp(M);
					}
					break;
					//清空线性表，只留下表头
					case 3:
					state = L->ClearList();
					if (state == INFEASIBLE) cout << "The list doesn't 
					existed!" << endl;
					else {
						cout << "clear successfully! now the structure is:" << 
						endl;
						structure_disp(M);
					}
					break;
					//判断线性表是否空
					case 4:
					state = L->ListEmpty();
					if (state == INFEASIBLE) cout << "inexisted list!" << endl;
					else if (state == TRUE) cout << "empty!" << endl;
					else cout << "not empty!" << endl;
					break;
					//返回表长度
					case 5:
					state = L->ListLength();
					if (state == INFEASIBLE) cout << "empty list" << endl;
					else {
						cout << "the length is " << state << endl;
					}
					break;
					//获取第i个元素
					case 6:
					cout << "enter the index of the element:" << endl;
					//int i, e;
					cin >> i;
					state = L->GetElem(i, e);
					if (state == INFEASIBLE) cout << "empty list" << endl;
					else if (state == ERROR) cout << "can't find the element." 
					<< endl;
					else {
						cout << "the element is " << e << endl;
					}
					break;
					//返回元素的索引
					case 7:
					cout << "enter the num to be located:" << endl;
					//int e;
					cin >> e;
					state = L->LocateElem(e);
					if (state == INFEASIBLE) cout << "empty list" << endl;
					else if (state == ERROR) cout << "can't find the element." 
					<< endl;
					else {
						cout << "the element index is " << state << endl;
					}
					break;
					//返回前驱
					case 8:
					cout << "enter the elem:" << endl;
					//int e, pre;
					cin >> e;
					state = L->PriorElem(e, pre);
					if (state == INFEASIBLE) cout << "empty list" << endl;
					else if (state == ERROR) cout << "can't find the element." 
					<< endl;
					else {
						cout << "the prior element is " << pre << endl;
					}
					break;
					//返回后继
					case 9:
					cout << "enter the elem:" << endl;
					//int e, next;
					cin >> e;
					state = L->NextElem(e, next);
					if (state == INFEASIBLE) cout << "empty list" << endl;
					else if (state == ERROR) cout << "can't find the element." 
					<< endl;
					else {
						cout << "the next element is " << next << endl;
					}
					break;
					//在位置i插入元素
					case 10:
					//int i, e;
					cout << "enter the location:" << endl;
					cin >> i;
					cout << "enter the elem:" << endl;
					cin >> e;
					state = L->ListInsert(i, e);
					if (state == INFEASIBLE) cout << "empty list" << endl;
					else if (state == ERROR) cout << "wrong position!." << endl;
					else {
						cout << "insert successfully! traverse: ";
						L->ListTraverse();
					}
					break;
					//删除位置i的元素
					case 11:
					//int i, e;
					cout << "enter the location:" << endl;
					cin >> i;
					state = L->ListDelete(i, e);
					if (state == INFEASIBLE) cout << "empty list" << endl;
					else if (state == ERROR) cout << "wrong position!." << endl;
					else {
						cout << "delete successfully" << endl;
					}
					break;
					//遍历表
					case 12:
					state = L->ListTraverse();
					if (state == INFEASIBLE) cout << "empty list" << endl;
					else {
						cout << "traverse over." << endl;
					}
					break;
					//反转链表
					case 13:
					state = L->reverse();
					if (state == INFEASIBLE) cout << "empty list" << endl;
					else {
						cout << "reverse over. traverse: ";
						L->ListTraverse();
					}
					break;
					//删除倒数第n个元素
					case 14:
					state = L->del_n();
					if (state == INFEASIBLE) cout << "empty list" << endl;
					else if (state == ERROR) cout << "wrong position!." << endl;
					else {
						cout << "delete successfully" << endl;
					}
					break;
					// 链表排序
					case 15:
					state = L->SortList();
					if (state == INFEASIBLE) cout << "empty list" << endl;
					else {
						cout << "sort over. reverse: ";
						L->ListTraverse();
						cout << endl;
					}
					break;
					// 在末尾加入元素
					case 16:
					state = L->AddData();
					if (state == INFEASIBLE) cout << "empty list" << endl;
					break;
					// 保存
					case 17:
					cout << "enter the filename:" << endl;
					scanf("%s", name);
					state = L->SaveList(name);
					if (state == INFEASIBLE) cout << "empty list" << endl;
					else {
						cout << "save successfully!" << endl;
					}
					break;
					// 导入
					case 18:
					cout << "enter the filename:" << endl;
					scanf("%s", name);
					state = L->LoadList(name);
					if (state == INFEASIBLE) cout << "list existed!" << endl;
					else {
						cout << "load successfully! Now the structure is:" << 
						endl;
						structure_disp(M);
					}
					break;
					default:
					cout << "wrong command!" << endl;
				}
				menu_disp();
				cout << "input your command:" << endl;
				cin >> op;
			}
			cout << "you have been backed to the main menu:" << endl;
			main_menu();
			return OK;
		}
	\end{lstlisting}
\end{document}