\documentclass[supercite]{Experimental_Report}

\usepackage{algorithm, multirow}
\usepackage{algpseudocode}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{framed}
\usepackage{mathtools}
\usepackage{subcaption}
\usepackage{xltxtra} %提供了针对XeTeX的改进并且加入了XeTeX的LOGO, 自动调用xunicode
%宏包(提供Unicode字符宏)
\usepackage{bm}
\usepackage{tikz}
\usepackage{tikzscale}
\usepackage{pgfplots}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{fontspec}

%%%%%%settings%%%%%%%%%
\pgfplotsset{compat=1.16}
\setmonofont{Consolas}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\lstset{ %
	backgroundcolor=\color{white},   % choose the background color
	basicstyle=\footnotesize\ttfamily,        % size of fonts used for the code
	columns=fullflexible,
	breaklines=true,                 % automatic line breaking only atwhitespace
	captionpos=b,                    % sets the caption-position to bottom
	tabsize=4,
	commentstyle=\color{mygreen},    % comment style
	escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
	keywordstyle=\color{blue},       % keyword style
	stringstyle=\color{mymauve}\ttfamily,     % string literal style
	frame=single,
	rulesepcolor=\color{red!20!green!20!blue!20},
	% identifierstyle=\color{red},
	language=c++,
}

\begin{document}
	\section{附录A 基于顺序存储结构线性表实现的源程序}
	\begin{center}
		\textbf{/* Linear Table On Sequence Structure */}
	\end{center}
	main.cpp
	\begin{lstlisting}
		#include "def.h"
		#include "Management.h"
		#include "SingleList.h"
		#include "command_op.h"
		using namespace std;
		
		int main()
		{
			int command;
			cout << "Initializing..." << "\n";
			List L;
			L.Init();
			cout << "A list(size 10) has been created" << "\n";
			cout << "Use the following command to operate the list.\n";
			main_menu_disp();
			cin >> command;
			while (command){
				response(L, command);  // 获取线性表管理命令，跳转到处理语句
				cin >> command;
			}
			cout << "bye" << endl;
			system("pause");
			return 0;
		}
	\end{lstlisting}
	def.h
	\begin{lstlisting}
		#pragma once
		#include <iostream>
		#include <fstream>
		#include <vector>
		#include <string>
		#include <algorithm>
		#include "stdio.h"
		#include "stdlib.h"
		#include "stdio.h"
		
		using namespace std;
		
		#define TRUE 1
		#define FALSE 0
		#define OK 1
		#define ERROR 0
		#define INFEASIBLE -1
		#define OVERFLOW -2
		
		typedef int status;
		typedef int ElemType; //数据元素类型定义
		
		#define LIST_INIT_SIZE 100
		#define LISTINCREMENT  10
		typedef int ElemType;
	\end{lstlisting}
	SingleList.h
	\begin{lstlisting}
		#include "def.h"
		# pragma once
		
		class SqList {
			private:
			int* elem;
			int length;
			int listsize;
			string name;
			
			public:
			SqList();
			
			//获取表名
			string GetName();
			
			//初始化
			status InitList(string name);
			
			//为刚刚初始化的表读入数据
			status ReadData();
			
			status DestroyList();
			
			status ClearList();
			
			//线性表判空
			status ListEmpty();
			
			//线性表长度
			status ListLength();
			
			//获取元素
			status GetElem(int i, ElemType &e);
			
			//查找元素
			int LocateElem(ElemType e);
			
			//获取前驱
			status PriorElem(ElemType e,ElemType &pre);
			
			//获取后继
			status NextElem(ElemType e,ElemType &next);
			
			//将元素e插入到线性表L的第i个元素之前
			status ListInsert(int i,ElemType e);
			
			//删除线性表L的第i个元素，保存在e中
			status ListDelete(int i,ElemType &e);
			
			//遍历线性表
			status ListTraverse();
			
			//最大连续子序列
			status MaxSubArr();
			
			//排序
			void SortList();
			
			//和为k的子数组
			status SubArrNum(int k);
			//保存表作为友元
			//friend status List::Save(string fname);
		};
	\end{lstlisting}
	SingleList.cpp
	\begin{lstlisting}
		#include "SingleList.h"
		
		SqList::SqList(){
			this->elem = nullptr;
		}
		
		string SqList::GetName(){
			return this->name;
		}
		
		status SqList::InitList(string name){
			if (this->elem != nullptr) return INFEASIBLE;
			else{
				this->elem = (int*)malloc(sizeof(int)*LIST_INIT_SIZE);
				this->length = 0;
				this->listsize = LIST_INIT_SIZE;
				this->name = name;
				return OK;
			}
		}
		
		status SqList::ReadData(){
			if (this->elem == nullptr) return INFEASIBLE;
			if (this->length != 0) return ERROR;
			else{
				cout << "enter a series of numbers ended with 0, seperated with 
				a space:\n";
				int num;
				cin >> num;
				while (num){
					if (this->length == this->listsize){
						return OVERFLOW;
					}
					this->elem[this->length++] = num;
					// cout << this->length << endl;
					cin >> num;
				}
				// cout << "read:" << endl;
				// for(int i = 0; i < this->length; i++){
					//     cout << this->elem[i] << " ";
					// }
				//cout << "\n";
				return OK;
			}
			
		}
		status SqList::DestroyList(){
			if (this->elem == nullptr) return INFEASIBLE;
			else{
				ElemType* p = this->elem;
				this->elem = nullptr;
				delete p;
				return OK;
			}
		}
		
		status SqList::ClearList(){
			if (this->elem == nullptr) return INFEASIBLE;
			else{
				this->length = 0;
				return OK;
			}
		}
		
		status SqList::ListEmpty(){
			if (this->elem == nullptr) return INFEASIBLE;
			else{
				return this->length == 0 ? TRUE : FALSE;
			}
		}
		
		status SqList::ListLength(){
			if (this->elem) return this->length;
			else return INFEASIBLE;
		}
		
		status SqList::GetElem(int i, ElemType &e){
			if (this->elem == nullptr) return INFEASIBLE;
			else{
				if (i > this->length || i <= 0) return ERROR;
				else {
					e = this->elem[i-1];
					return OK;
				}
			}
		}
		
		int SqList::LocateElem(ElemType e){
			if (this->elem == nullptr) return INFEASIBLE;
			else{
				for (int i = 0; i < this->length; i++){
					if (this->elem[i] == e) return i+1;
				}
				return 0;
			}
		}
		
		status SqList::PriorElem(ElemType e, ElemType &pre){
			if (this->elem == nullptr) return INFEASIBLE;
			if (this->length == 0 || this->elem[0] == e) return ERROR;
			for (int i = 0; i < this->length-1; i++){
				if (this->elem[i+1] == e){
					pre = this->elem[i];
					return OK;
				}
			}
			return ERROR;
		}
		
		status SqList::NextElem(ElemType e, ElemType &next){
			if (this->elem == nullptr) return INFEASIBLE;
			if (this->length <= 1 || this->elem[this->length-1] == e) return 
			ERROR;
			for (int i = 0; i < this->length-1; i++){
				if (this->elem[i] == e){
					next = this->elem[i+1];
					return OK;
				}
			}
			return ERROR;
		}
		
		status SqList::ListInsert(int i, ElemType e){
			if (this->elem == nullptr) return INFEASIBLE;
			if (i <= 0) return ERROR;
			//还未用new重写
			this->elem = (int*)realloc(this->elem, sizeof(int)*100);
			if (i == this->length+1){
				this->elem[this->length++] = e;
				return OK;
			}
			if (i > this->length) return ERROR;
			
			for (int j = this->length-1; j >= i-1; j--){
				this->elem[j+1] = this->elem[j];
			}
			this->elem[i-1] = e;
			this->length++;
			return OK;
		}
		
		status SqList::ListDelete(int i, ElemType &e){
			if (this->elem == nullptr) return INFEASIBLE;
			if (i <= 0 || i > this->length) return ERROR;
			e = this->elem[i-1];
			for (int j = i-1; j < this->length-1; j++){
				this->elem[j] = this->elem[j+1];
			}
			this->length--;
			return OK;
		}
		
		status SqList::ListTraverse(){
			if (this->elem == nullptr) return INFEASIBLE;
			cout << this->GetName() << ": ";
			for(int i = 0; i < this->length; i++){
				cout << this->elem[i] << " ";
			}
			cout << "\n";
			return OK;
		}
		
		status SqList::MaxSubArr(){
			if (!this->elem) return INFEASIBLE;
			else if (this->length == 0) return INFEASIBLE;
			else{
				vector<int> dp(this->length, 0);
				dp[0] = max(0, this->elem[0]);
				int ans = 0;
				for (int i = 1; i < this->length; i++){
					dp[i] = dp[i-1] + this->elem[i];
					if (dp[i] < 0) dp[i] = 0;
					ans = max(ans, dp[i]);
				}
				return ans;
			}
		}
		
		void SqList::SortList(){
			sort(this->elem, this->elem+this->length);
		}
		
		status SqList::SubArrNum(int k){
			if (!this->elem) return INFEASIBLE;
			vector<int> presum(this->length+1, 0);
			presum[1] = this->elem[0];
			for (int i = 1; i < this->length; i++){
				presum[i+1] = presum[i] + this->elem[i];
			}
			int ans = 0;
			for (int i = 0; i < this->length; i++){
				for (int j = i+1; j <= this->length; j++){
					if (presum[j] - presum[i] == k) ans++;
				}
			}
			return ans;
		}
	\end{lstlisting}
	Management.h
	\begin{lstlisting}
		#include "def.h"
		#include "SingleList.h"
		#pragma once
		
		class List {
			private:
			int length;
			int listsize;
			vector<SqList> lists = vector<SqList>(10);
			public:
			//初始化一张表
			status Init();
			
			//获取当前表长
			int GetLen();
			
			//插入一个新子表
			status AddList(string name);
			
			//移除第一个一个名字为name的子表
			status RemoveList(string name);
			
			//返回一个子表
			SqList& Query(int index);
			
			//查找第一个名为name的子表
			int LocateList(string name);
			
			//保存表
			status Save(string fname);
			
			//从文件读取数据使表初始化
			status Load(string fname);
		};
	\end{lstlisting}
	Management.cpp
	\begin{lstlisting}
		#include "Management.h"
		
		status List::Init(){
			this->length = 0;
			this->listsize = 10;
			return OK;
		}
		
		int List::GetLen(){
			return this->length;
		}
		status List::AddList(string name){
			if (this->length == this->listsize) cout << "List has been full!" 
			<< endl;
			int state = this->lists[this->length++].InitList(name);
			if (state == OK) cout << "Add successfully\n" << endl;
			return OK;
		}
		
		status List::RemoveList(string name){
			for (int i = 0; i < this->length; i++){
				//printf("%d\n", i);
				if (this->lists[i].GetName() == name){
					this->lists[i].DestroyList();
					for (int j = i; j < this->length-1; j++){
						this->lists[j] = this->lists[j+1];
					}
					this->length--;
					//printf("%d\n", i);
					return OK;
				}
			}
			return ERROR;
		}
		
		SqList& List::Query(int index){
			return this->lists[index-1];
		}
		
		status List::LocateList(string name){
			for (int i = 0; i < this->length; i++){
				if (this->lists[i].GetName() == name){
					return i+1;
				}
			}
			return 0;
		}
		
		status List::Save(string fname){
			ofstream ofile(fname, ios::app);
			cout << "creating file...";
			if (ofile){
				cout << "done!" << endl;
				cout << "reading..." << endl;
				for (int i = 0; i < this->length; i++){
					SqList sublist = this->lists[i];
					ofile << sublist.GetName() << " ";
					int e;
					for (int j = 1; j <= sublist.ListLength(); j++){
						int state = sublist.GetElem(j, e);
						ofile << e << " ";
					}
					ofile << 0 << endl;
				}
				cout << "done!" << endl;
				return OK;
			}
			cout << "error!" << endl;
			return ERROR;
		}
		
		status List::Load(string fname){
			ifstream infile(fname, ios::in);
			cout << "opening file...";
			if (infile){
				cout << "done!" << endl;
				string name;
				int i = 0;  //当前在处理第几个列表
				while (infile >> name){
					this->AddList(name);
					SqList& sublist = this->lists[i];
					//sublist.InitList(name);
					int num;
					infile >> num;
					while (num){
						sublist.ListInsert(1, num);
						cout << "insert" << num << endl;
						infile >> num;
					}
					i++;
				}
				return OK;
			}
			return ERROR;
		}
	\end{lstlisting}
	command\_op.h
	\begin{lstlisting}
		#include "def.h"
		#include "Management.h"
		#include "SingleList.h"
		#pragma once
		
		//线性表管理菜单
		void main_menu_disp();
		
		//单个表管理菜单
		void sub_menu_disp();
		
		//主表操作
		void response(List& L, int command);
		
		//子表操作
		void operate_single_list(SqList &SubL);
	\end{lstlisting}
	command\_op.cpp
	\begin{lstlisting}
		#include "command_op.h"
		
		void main_menu_disp(){
			printf("      Menu for Linear Table On Sequence Structure 
			Management \n");
			printf("-------------------------------------------------\n");
			printf("    	  1. add_a_list       4. goto_a_list\n");
			printf("    	  2. remove_a_list    5. save_as_file\n");
			printf("    	  3. locate_a_list    6. load_from_file\n");
			printf("          0. quit\n");
			printf("-------------------------------------------------\n");
			
		}
		
		void sub_menu_disp(){
			printf("      Menu for Linear Table On Single List \n");
			printf("-------------------------------------------------\n");
			printf("    	  1. InitList       7. GetElem\n");
			printf("    	  2. read_data      8. LocateElem\n");
			printf("    	  3. DestroyList       9. PriorElem \n");
			printf("    	  4. ClearList     10. NextElemt\n");
			printf("    	  5. ListEmpty     11. ListInsert\n");
			printf("    	  6. ListLength       12. ListDelete\n");
			printf("    	  13. ListTraverse     14. MaxSubArr\n");  
			printf("          15.SortList           16. SubArrSum\n");  
			printf("          0.quit\n");
			printf("-------------------------------------------------\n");
			
		}
		
		void response(List& L, int command){
			string name;
			if (command == 1){  // 初始化新建一个表
				cout << "input name:\n";
				cin >> name;
				while (name == "\n"){
					cout << "please enter a name:";
					cin >> name;
				}
				L.AddList(name);
			}
			else if (command == 2){  // 移除表
				cout << "enter the name of the list to be removed\n";
				cin >> name;
				int state = L.RemoveList(name);
				if (state == OK){
					cout << "remove successfully\n";
				}
				else{
					cout << "Can't find sublist named" << name << "!\n";
				}
			}
			else if (command == 3){  // 根据名字定位表
				cout << "enter the name:" << endl;
				cin >> name;
				int state = L.LocateList(name);
				if (state == 0){
					cout << "Can't find sublist named " << name << "!\n";
				}
				else{
					cout << "The sublist named " << name << " locates in " << 
					state << \
					"th position.\n"; 
				}
			}
			else if (command == 4){  // 进入单表中进行操作
				cout << "enter the name of the sublist:\n";
				cin >> name;
				int state = L.LocateList(name);
				if (state == 0){
					cout << "wrong name!\n";
				}
				else{
					SqList& sublist = L.Query(state);  //这里如果不用引用来接受返
					回值，后面会出问题！！！会导致本体并没有改变！！！
					operate_single_list(sublist);
				}
				
			}
			else if (command == 5){  // 保存
				cout << "file name?" << endl;
				string fname;
				cin >> fname;
				int state = L.Save(fname);
				if (state == OK) cout << "save successfully!" << endl;
				else cout << "error!" << endl;
			}
			else if (command == 6){  // 导入
				cout << "file name?" << endl;
				string fname;
				cin >> fname;
				int state = L.Load(fname);
				if (state == OK) cout << "load successfully!" << endl;
				else cout << "error!" << endl;
			}
			else{
				cout << "invalid command!" << endl;
			}
			cout << "your next command?" << endl;
		}
		
		
		//子表操作
		void operate_single_list(SqList& SubL){
			//system("cls");
			cout << "you have been entered list " << SubL.GetName() << endl;
			cout << "list command are as follows:" << endl;
			sub_menu_disp();
			int command;
			int state;
			string name;
			cout << "your command?\n";
			cin >> command;
			while (command){
				//初始化单个表
				if (command == 1){
					cout << "enter a name for this list:\n";
					cin >> name;
					state = SubL.InitList(name);
					if (state == INFEASIBLE){
						cout << "You can't initialize an existed list!\n";
					}
					else{
						cout << "initialize successfully!\n";
					}
				}
				//读取数据
				else if (command == 2){
					state = SubL.ReadData();
					if (state == INFEASIBLE){
						cout << "inexisted list!\n";
					}
					else if (state == OVERFLOW){
						cout << "too many numbers! some has been lost!" << "\n";
					}
					else if (state == ERROR){
						cout << "some elements have been exist!" << endl;
					}
					else{
						cout << "read successfully!\n";
					}
				}
				//删除列表使之变为null
				else if (command == 3){
					state = SubL.DestroyList();
					if (state == INFEASIBLE){
						cout << "You can't destroy an inexisted list!\n";
					}
					else{
						cout << "destroy successfully!\n";
					}
				}
				//清空列表，但表仍然存在
				else if (command == 4){
					state = SubL.ClearList();
					if (state == INFEASIBLE){
						cout << "You can't clear an inexisted list!\n";
					}
					else{
						cout << "clear successfully!\n";
					}
				}
				//判断列表是否空
				else if (command == 5){
					state = SubL.ListEmpty();
					if (state == INFEASIBLE){
						cout << "list inexists\n";
					}
					else{
						if (state == 1) cout << "empty!" << endl;
						else cout << "not empty!" << endl;
					}
				}
				//获取列表长度
				else if (command == 6){
					state = SubL.ListLength();
					if (state == INFEASIBLE){
						cout << "inexisted list!\n";
					}
					else{
						cout << "the length is " << state << "\n";
					}
				}
				//获取指定位置元素
				else if (command == 7){
					int index, e;
					cout << "please enter the index:\n";
					cin >> index;
					state = SubL.GetElem(index, e);
					if (state == INFEASIBLE){
						cout << "inexisted list!\n";
					}
					else if (state == ERROR){
						cout << "index out of range!\n";
					}
					else{
						cout << "The elem is " << e << "\n";
					}
				}
				//获取指定元素位置
				else if (command == 8){
					int e;
					cout << "enter the element:\n";
					cin >> e;
					state = SubL.LocateElem(e);
					if (state == INFEASIBLE){
						cout << "inexisted list!\n";
					}
					else if (state == 0){
						cout << "Element " << e << " doesn't exist!\n" << endl;
					}
					else{
						cout << "position is" << state << "\n";
					}
				}
				//获取前驱
				else if (command == 9){
					int e, pre;
					cout << "enter the element:\n";
					cin >> e;
					state = SubL.PriorElem(e, pre);
					if (state == INFEASIBLE){
						cout << "inexisted list!\n";
					}
					else if (state == 0){
						cout << "prior element doesn't exist!\n" << endl;
					}
					else{
						cout << "prior element is " << pre << "\n";
					}
				}
				//获取后继
				else if (command == 10){
					int e, next;
					cout << "enter the element:\n";
					cin >> e;
					state = SubL.NextElem(e, next);
					if (state == INFEASIBLE){
						cout << "inexisted list!\n";
					}
					else if (state == 0){
						cout << "next element doesn't exist!\n" << endl;
					}
					else{
						cout << "next element is " << next << "\n";
					}
				}
				//插入元素
				else if (command == 11){
					int e, i;
					cout << "enter the element:\n";
					cin >> e;
					cout << "enter the position:\n";
					cin >> i;
					state = SubL.ListInsert(i, e);
					if (state == INFEASIBLE){
						cout << "inexisted list!\n";
					}
					else if (state == 0){
						cout << "wrong insert position!\n" << endl;
					}
					else{
						cout << "insert successfully!\n";
					}
				}
				//删除元素
				else if (command == 12){
					int e, i;
					cout << "enter the position to be deleted:\n";
					cin >> i;
					state = SubL.ListDelete(i, e);
					if (state == INFEASIBLE){
						cout << "inexisted list!\n";
					}
					else if (state == 0){
						cout << "wrong delete position!\n" << endl;
					}
					else{
						cout << "delete successfully!\n";
					}
				}
				//遍历表
				else if (command == 13){
					state = SubL.ListTraverse();
					if (state == INFEASIBLE){
						cout << "inexisted list!\n";
					}
					else{
						cout << "traverse over\n";
					}
				}
				else if (command == 14){
					state = SubL.MaxSubArr();
					if (state == INFEASIBLE){
						cout << "inexisted list or the length less than 1!" << 
						endl;
					}
					else{
						cout << "the max sum is " << state << endl;
					}
				}
				else if (command == 15){
					SubL.SortList();
				}
				else if (command == 16){
					cout << "enter the sum k" << endl;
					int k;
					cin >> k;
					state = SubL.SubArrNum(k);
					if (state == INFEASIBLE){
						cout << "inexisted list" << endl;
					}
					else{
						cout << "the num sumed k is " << state << endl;
					}
				}
				else{
					cout << "invalid command!" << endl;
				}
				cout << "your command?\n";
				cin >> command;
			}
			
			//system("cls");
			cout << "you have been backed to the manager.Choose your command." 
			<< endl;
			main_menu_disp();
		}
	\end{lstlisting}
\end{document}